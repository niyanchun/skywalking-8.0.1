{"remainingRequest":"/Volumes/Files/Study/apm/apache-skywalking-apm-8.0.1/skywalking-ui/node_modules/vue-loader/lib/index.js??vue-loader-options!/Volumes/Files/Study/apm/apache-skywalking-apm-8.0.1/skywalking-ui/src/views/components/trace/trace-detail-chart-list.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Volumes/Files/Study/apm/apache-skywalking-apm-8.0.1/skywalking-ui/src/views/components/trace/trace-detail-chart-list.vue","mtime":1592485041000},{"path":"/Volumes/Files/Study/apm/apache-skywalking-apm-8.0.1/skywalking-ui/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Volumes/Files/Study/apm/apache-skywalking-apm-8.0.1/skywalking-ui/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Volumes/Files/Study/apm/apache-skywalking-apm-8.0.1/skywalking-ui/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport copy from '@/utils/copy';\nimport * as d3 from 'd3';\nimport Trace from './d3-trace';\nimport _ from 'lodash';\nexport default {\n  props: ['data', 'traceId'],\n  data() {\n    return {\n      segmentId: [],\n      showDetail: false,\n      list: [],\n      currentSpan: [],\n      loading: true,\n    };\n  },\n  watch: {\n    data() {\n      if (!this.data.length) { return; }\n      this.loading = true;\n      this.changeTree();\n      this.tree.init({label: 'TRACE_ROOT', children: this.segmentId}, this.data);\n      this.tree.draw(() => {\n        setTimeout(() => {\n          this.loading = false;\n        }, 200);\n      });\n    },\n  },\n  beforeDestroy() {\n    d3.selectAll('.d3-tip').remove();\n  },\n  mounted() {\n    this.$eventBus.$on('TRACE-LIST-LOADING', this, () => { this.loading = true; });\n    // this.loading = true;\n    this.changeTree();\n    this.tree = new Trace(this.$refs.traceList, this);\n    this.tree.init({label: 'TRACE_ROOT', children: this.segmentId}, this.data);\n    this.tree.draw();\n    this.loading = false;\n    // this.computedScale();\n  },\n  methods: {\n    copy,\n    handleSelectSpan(i) {\n      this.currentSpan = i.data;\n      this.showDetail = true;\n    },\n    traverseTree(node, spanId, segmentId, data) {\n      if (!node) { return; }\n      if (node.spanId === spanId && node.segmentId === segmentId) {\n        node.children.push(data);\n        return;\n      }\n      if (node.children && node.children.length > 0) {\n        node.children.forEach((nodeItem) => {\n          this.traverseTree(nodeItem, spanId, segmentId, data);\n        });\n      }\n    },\n    computedScale(i) {\n       // Rainbow map\n      const sequentialScale = d3.scaleSequential()\n      .domain([0, this.list.length + 1])\n      .interpolator(d3.interpolateCool);\n      return sequentialScale(i);\n    },\n    changeTree() {\n      if (this.data.length === 0) {\n        return [];\n      }\n      this.list = Array.from(new Set(this.data.map((i) => i.serviceCode)));\n      this.segmentId = [];\n      const segmentGroup = {};\n      const segmentIdGroup = [];\n      const fixSpans = [];\n      const segmentHeaders = [];\n      this.data.forEach((span) => {\n        if (span.parentSpanId === -1) {\n          segmentHeaders.push(span);\n        } else {\n          const index = this.data.findIndex((i) => (\n            i.segmentId === span.segmentId\n            &&\n            i.spanId === (span.spanId - 1)\n          ));\n          const fixSpanKeyContent = {\n            traceId: span.traceId,\n            segmentId: span.segmentId,\n            spanId: span.spanId - 1,\n            parentSpanId: span.spanId - 2,\n          };\n          if (index === -1 && !_.find(fixSpans, fixSpanKeyContent)) {\n            fixSpans.push(\n              {\n                ...fixSpanKeyContent,\n                refs: [],\n                endpointName: `VNode: ${span.segmentId}`,\n                serviceCode: 'VirtualNode',\n                type: `[Broken] ${span.type}`,\n                peer: '',\n                component: `VirtualNode: #${span.spanId - 1}`,\n                isError: true,\n                isBroken: true,\n                layer: 'Broken',\n                tags: [],\n                logs: [],\n              },\n            );\n          }\n        }\n      });\n      segmentHeaders.forEach((span) => {\n        if (span.refs.length) {\n          span.refs.forEach((ref) => {\n            const index = this.data.findIndex((i) => (\n              ref.parentSegmentId === i.segmentId\n              &&\n              ref.parentSpanId === i.spanId\n            ));\n            if (index === -1) {\n              // create a known broken node.\n              const i = ref.parentSpanId;\n              const fixSpanKeyContent = {\n                traceId: ref.traceId,\n                segmentId: ref.parentSegmentId,\n                spanId: i,\n                parentSpanId: i > -1 ? 0 : -1,\n              };\n              if (!_.find(fixSpans, fixSpanKeyContent)) {\n                fixSpans.push({\n                    ...fixSpanKeyContent, refs: [], endpointName: `VNode: ${ref.parentSegmentId}`,\n                  serviceCode: 'VirtualNode', type: `[Broken] ${ref.type}`, peer: '', component: `VirtualNode: #${i}`,\n                  isError: true, isBroken: true, layer: 'Broken', tags: [], logs: [],\n                });\n              }\n              // if root broken node is not exist, create a root broken node.\n              if (fixSpanKeyContent.parentSpanId > -1) {\n                const fixRootSpanKeyContent = {\n                  traceId: ref.traceId,\n                  segmentId: ref.parentSegmentId,\n                  spanId: 0,\n                  parentSpanId: -1,\n                };\n                if (!_.find(fixSpans, fixRootSpanKeyContent)) {\n                  fixSpans.push({\n                    ...fixRootSpanKeyContent,\n                    refs: [],\n                    endpointName: `VNode: ${ref.parentSegmentId}`,\n                    serviceCode: 'VirtualNode',\n                    type: `[Broken] ${ref.type}`,\n                    peer: '',\n                    component: `VirtualNode: #0`,\n                    isError: true,\n                    isBroken: true,\n                    layer: 'Broken',\n                    tags: [],\n                    logs: [],\n                  });\n                }\n              }\n            }\n          });\n        }\n      });\n      [...fixSpans, ...this.data].forEach((i) => {\n        i.label = i.endpointName || 'no operation name';\n        i.children = [];\n        if (segmentGroup[i.segmentId] === undefined) {\n          segmentIdGroup.push(i.segmentId);\n          segmentGroup[i.segmentId] = [];\n          segmentGroup[i.segmentId].push(i);\n        } else {\n          segmentGroup[i.segmentId].push(i);\n        }\n      });\n      segmentIdGroup.forEach((id) => {\n        const currentSegment = segmentGroup[id].sort((a, b) => b.parentSpanId - a.parentSpanId);\n        currentSegment.forEach((s) => {\n          const index = currentSegment.findIndex((i) => i.spanId === s.parentSpanId);\n          if (index !== -1) {\n            if (\n              (currentSegment[index].isBroken && currentSegment[index].parentSpanId === -1)\n              ||\n              !currentSegment[index].isBroken\n            ) {\n              currentSegment[index].children.push(s);\n              currentSegment[index].children.sort((a, b) => a.spanId - b.spanId);\n            }\n          }\n          if (s.isBroken) {\n            const children = _.filter(this.data, (span) => {\n              return _.find(span.refs, {traceId: s.traceId, parentSegmentId: s.segmentId, parentSpanId: s.spanId});\n            });\n            if (children.length > 0) {\n              s.children.push(...children);\n            }\n          }\n        });\n        segmentGroup[id] = currentSegment[currentSegment.length - 1];\n      });\n      segmentIdGroup.forEach((id) => {\n        segmentGroup[id].refs.forEach((ref) => {\n          if (ref.traceId === this.traceId) {\n            this.traverseTree(\n              segmentGroup[ref.parentSegmentId],\n              ref.parentSpanId,\n              ref.parentSegmentId,\n              segmentGroup[id]);\n          }\n        });\n      });\n      for (const i in segmentGroup) {\n        if (segmentGroup[i].refs.length === 0 ) {\n          this.segmentId.push(segmentGroup[i]);\n        }\n      }\n      this.segmentId.forEach((i) => {\n        this.collapse(i);\n      });\n    },\n    collapse(d) {\n      if (d.children) {\n        let dur = d.endTime - d.startTime;\n        d.children.forEach((i) => {\n          dur -= (i.endTime - i.startTime);\n        });\n        d.dur = dur < 0 ? 0 : dur;\n        d.children.forEach((i) => this.collapse(i));\n      }\n    },\n    showCurrentSpanDetail(title, text) {\n      const textLineNumber = text.split('\\n').length;\n      let textHeight = textLineNumber * 20.2 + 10;\n      const tmpHeight = window.innerHeight * 0.9;\n      textHeight = textHeight >= tmpHeight ? tmpHeight : textHeight;\n      this.$modal.show('dialog', {\n        title,\n        text: `<div style=\"height:${textHeight}px\">${text}</div>`,\n        buttons: [\n          {\n            title: 'Copy',\n            handler: () => {\n              this.copy(text);\n            },\n          },\n          {\n            title: 'Close',\n          },\n        ],\n      });\n    },\n    downloadTrace() {\n      const serializer = new XMLSerializer();\n      const svgNode = d3.select('.trace-list-dowanload').node();\n      const source = `<?xml version=\"1.0\" standalone=\"no\"?>\\r\\n${serializer.serializeToString(svgNode)}`;\n      const canvas = document.createElement('canvas');\n      const context = canvas.getContext('2d');\n      canvas.width = d3.select('.trace-list-dowanload')._groups[0][0].clientWidth;\n      canvas.height = d3.select('.trace-list-dowanload')._groups[0][0].clientHeight;\n      context.fillStyle = '#fff';\n      context.fillRect(0, 0, canvas.width, canvas.height);\n      const image = new Image();\n      image.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(source)}`;\n      image.onload = () => {\n        context.drawImage(image, 0, 0);\n        const tagA = document.createElement('a');\n        tagA.download = 'trace-list.png';\n        tagA.href = canvas.toDataURL('image/png');\n        tagA.click();\n      };\n    },\n  },\n};\n",{"version":3,"sources":["trace-detail-chart-list.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"trace-detail-chart-list.vue","sourceRoot":"src/views/components/trace","sourcesContent":["<!-- Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. -->\n<template>\n  <div class=\"time-charts scroll_hide\">\n    <div class=\"rk-trace-t-loading\" v-show=\"loading\">\n      <svg class=\"icon loading\">\n        <use xlink:href=\"#spinner\"></use>\n      </svg>\n    </div>\n    <transition-group name=\"fade\" tag=\"a\" class=\"mb-5\">\n      <span class=\"time-charts-item mr-10\" v-for=\"(i, index) in list\" :key=\"i\" :style=\"`color:${computedScale(index)}`\">\n        <svg class=\"icon vm mr-5 sm\">\n          <use xlink:href=\"#issue-open-m\"></use>\n        </svg>\n        <span>{{ i }}</span>\n      </span>\n    </transition-group>\n    <a class=\"rk-btn r vm  tc\" @click=\"downloadTrace\">{{ $t('exportImage') }}</a>\n    <rk-sidebox :width=\"'50%'\" :show.sync=\"showDetail\" :title=\"$t('spanInfo')\">\n      <div class=\"rk-trace-detail\">\n        <h5 class=\"mb-15\">{{ $t('tags') }}.</h5>\n        <div class=\"mb-10 clear\">\n          <span class=\"g-sm-4 grey\">{{ $t('endpoint') }}:</span\n          ><span class=\"g-sm-8 wba\">{{ this.currentSpan.label }}</span>\n        </div>\n        <div class=\"mb-10 clear\">\n          <span class=\"g-sm-4 grey\">{{ $t('spanType') }}:</span\n          ><span class=\"g-sm-8 wba\">{{ this.currentSpan.type }}</span>\n        </div>\n        <div class=\"mb-10 clear\">\n          <span class=\"g-sm-4 grey\">{{ $t('component') }}:</span\n          ><span class=\"g-sm-8 wba\">{{ this.currentSpan.component }}</span>\n        </div>\n        <div class=\"mb-10 clear\">\n          <span class=\"g-sm-4 grey\">Peer:</span><span class=\"g-sm-8 wba\">{{ this.currentSpan.peer || 'No Peer' }}</span>\n        </div>\n        <div class=\"mb-10 clear\">\n          <span class=\"g-sm-4 grey\">{{ $t('error') }}:</span\n          ><span class=\"g-sm-8 wba\">{{ this.currentSpan.isError }}</span>\n        </div>\n        <div class=\"mb-10 clear\" v-for=\"i in this.currentSpan.tags\" :key=\"i.key\">\n          <span class=\"g-sm-4 grey\">{{ i.key }}:</span>\n          <span class=\"g-sm-8 wba\">\n            {{ i.value }}\n            <svg v-if=\"i.key === 'db.statement'\" class=\"icon vm grey link-hover cp ml-5\" @click=\"copy(i.value)\">\n              <use xlink:href=\"#review-list\"></use>\n            </svg>\n          </span>\n        </div>\n        <h5 class=\"mb-10\" v-if=\"this.currentSpan.logs\" v-show=\"this.currentSpan.logs.length\">{{ $t('logs') }}.</h5>\n        <div v-for=\"(i, index) in this.currentSpan.logs\" :key=\"index\">\n          <div class=\"mb-10 sm\">\n            <span class=\"mr-10\">{{ $t('time') }}:</span><span class=\"grey\">{{ i.time | dateformat }}</span>\n          </div>\n          <div class=\"mb-15 clear\" v-for=\"(_i, _index) in i.data\" :key=\"_index\">\n            <div class=\"mb-10\">\n              {{ _i.key }}:<span\n                v-if=\"_i.key === 'stack'\"\n                class=\"r rk-sidebox-magnify\"\n                @click=\"showCurrentSpanDetail(_i.key, _i.value)\"\n              >\n                <svg class=\"icon\">\n                  <use xlink:href=\"#magnify\"></use>\n                </svg>\n              </span>\n            </div>\n            <pre class=\"pl-15 mt-0 mb-0 sm oa\">{{ _i.value }}</pre>\n          </div>\n        </div>\n      </div>\n    </rk-sidebox>\n    <v-dialog width=\"90%\" />\n    <div class=\"trace-list\">\n      <div ref=\"traceList\"></div>\n    </div>\n  </div>\n</template>\n<script lang=\"js\">\n  import copy from '@/utils/copy';\n  import * as d3 from 'd3';\n  import Trace from './d3-trace';\n  import _ from 'lodash';\n  export default {\n    props: ['data', 'traceId'],\n    data() {\n      return {\n        segmentId: [],\n        showDetail: false,\n        list: [],\n        currentSpan: [],\n        loading: true,\n      };\n    },\n    watch: {\n      data() {\n        if (!this.data.length) { return; }\n        this.loading = true;\n        this.changeTree();\n        this.tree.init({label: 'TRACE_ROOT', children: this.segmentId}, this.data);\n        this.tree.draw(() => {\n          setTimeout(() => {\n            this.loading = false;\n          }, 200);\n        });\n      },\n    },\n    beforeDestroy() {\n      d3.selectAll('.d3-tip').remove();\n    },\n    mounted() {\n      this.$eventBus.$on('TRACE-LIST-LOADING', this, () => { this.loading = true; });\n      // this.loading = true;\n      this.changeTree();\n      this.tree = new Trace(this.$refs.traceList, this);\n      this.tree.init({label: 'TRACE_ROOT', children: this.segmentId}, this.data);\n      this.tree.draw();\n      this.loading = false;\n      // this.computedScale();\n    },\n    methods: {\n      copy,\n      handleSelectSpan(i) {\n        this.currentSpan = i.data;\n        this.showDetail = true;\n      },\n      traverseTree(node, spanId, segmentId, data) {\n        if (!node) { return; }\n        if (node.spanId === spanId && node.segmentId === segmentId) {\n          node.children.push(data);\n          return;\n        }\n        if (node.children && node.children.length > 0) {\n          node.children.forEach((nodeItem) => {\n            this.traverseTree(nodeItem, spanId, segmentId, data);\n          });\n        }\n      },\n      computedScale(i) {\n         // Rainbow map\n        const sequentialScale = d3.scaleSequential()\n        .domain([0, this.list.length + 1])\n        .interpolator(d3.interpolateCool);\n        return sequentialScale(i);\n      },\n      changeTree() {\n        if (this.data.length === 0) {\n          return [];\n        }\n        this.list = Array.from(new Set(this.data.map((i) => i.serviceCode)));\n        this.segmentId = [];\n        const segmentGroup = {};\n        const segmentIdGroup = [];\n        const fixSpans = [];\n        const segmentHeaders = [];\n        this.data.forEach((span) => {\n          if (span.parentSpanId === -1) {\n            segmentHeaders.push(span);\n          } else {\n            const index = this.data.findIndex((i) => (\n              i.segmentId === span.segmentId\n              &&\n              i.spanId === (span.spanId - 1)\n            ));\n            const fixSpanKeyContent = {\n              traceId: span.traceId,\n              segmentId: span.segmentId,\n              spanId: span.spanId - 1,\n              parentSpanId: span.spanId - 2,\n            };\n            if (index === -1 && !_.find(fixSpans, fixSpanKeyContent)) {\n              fixSpans.push(\n                {\n                  ...fixSpanKeyContent,\n                  refs: [],\n                  endpointName: `VNode: ${span.segmentId}`,\n                  serviceCode: 'VirtualNode',\n                  type: `[Broken] ${span.type}`,\n                  peer: '',\n                  component: `VirtualNode: #${span.spanId - 1}`,\n                  isError: true,\n                  isBroken: true,\n                  layer: 'Broken',\n                  tags: [],\n                  logs: [],\n                },\n              );\n            }\n          }\n        });\n        segmentHeaders.forEach((span) => {\n          if (span.refs.length) {\n            span.refs.forEach((ref) => {\n              const index = this.data.findIndex((i) => (\n                ref.parentSegmentId === i.segmentId\n                &&\n                ref.parentSpanId === i.spanId\n              ));\n              if (index === -1) {\n                // create a known broken node.\n                const i = ref.parentSpanId;\n                const fixSpanKeyContent = {\n                  traceId: ref.traceId,\n                  segmentId: ref.parentSegmentId,\n                  spanId: i,\n                  parentSpanId: i > -1 ? 0 : -1,\n                };\n                if (!_.find(fixSpans, fixSpanKeyContent)) {\n                  fixSpans.push({\n                      ...fixSpanKeyContent, refs: [], endpointName: `VNode: ${ref.parentSegmentId}`,\n                    serviceCode: 'VirtualNode', type: `[Broken] ${ref.type}`, peer: '', component: `VirtualNode: #${i}`,\n                    isError: true, isBroken: true, layer: 'Broken', tags: [], logs: [],\n                  });\n                }\n                // if root broken node is not exist, create a root broken node.\n                if (fixSpanKeyContent.parentSpanId > -1) {\n                  const fixRootSpanKeyContent = {\n                    traceId: ref.traceId,\n                    segmentId: ref.parentSegmentId,\n                    spanId: 0,\n                    parentSpanId: -1,\n                  };\n                  if (!_.find(fixSpans, fixRootSpanKeyContent)) {\n                    fixSpans.push({\n                      ...fixRootSpanKeyContent,\n                      refs: [],\n                      endpointName: `VNode: ${ref.parentSegmentId}`,\n                      serviceCode: 'VirtualNode',\n                      type: `[Broken] ${ref.type}`,\n                      peer: '',\n                      component: `VirtualNode: #0`,\n                      isError: true,\n                      isBroken: true,\n                      layer: 'Broken',\n                      tags: [],\n                      logs: [],\n                    });\n                  }\n                }\n              }\n            });\n          }\n        });\n        [...fixSpans, ...this.data].forEach((i) => {\n          i.label = i.endpointName || 'no operation name';\n          i.children = [];\n          if (segmentGroup[i.segmentId] === undefined) {\n            segmentIdGroup.push(i.segmentId);\n            segmentGroup[i.segmentId] = [];\n            segmentGroup[i.segmentId].push(i);\n          } else {\n            segmentGroup[i.segmentId].push(i);\n          }\n        });\n        segmentIdGroup.forEach((id) => {\n          const currentSegment = segmentGroup[id].sort((a, b) => b.parentSpanId - a.parentSpanId);\n          currentSegment.forEach((s) => {\n            const index = currentSegment.findIndex((i) => i.spanId === s.parentSpanId);\n            if (index !== -1) {\n              if (\n                (currentSegment[index].isBroken && currentSegment[index].parentSpanId === -1)\n                ||\n                !currentSegment[index].isBroken\n              ) {\n                currentSegment[index].children.push(s);\n                currentSegment[index].children.sort((a, b) => a.spanId - b.spanId);\n              }\n            }\n            if (s.isBroken) {\n              const children = _.filter(this.data, (span) => {\n                return _.find(span.refs, {traceId: s.traceId, parentSegmentId: s.segmentId, parentSpanId: s.spanId});\n              });\n              if (children.length > 0) {\n                s.children.push(...children);\n              }\n            }\n          });\n          segmentGroup[id] = currentSegment[currentSegment.length - 1];\n        });\n        segmentIdGroup.forEach((id) => {\n          segmentGroup[id].refs.forEach((ref) => {\n            if (ref.traceId === this.traceId) {\n              this.traverseTree(\n                segmentGroup[ref.parentSegmentId],\n                ref.parentSpanId,\n                ref.parentSegmentId,\n                segmentGroup[id]);\n            }\n          });\n        });\n        for (const i in segmentGroup) {\n          if (segmentGroup[i].refs.length === 0 ) {\n            this.segmentId.push(segmentGroup[i]);\n          }\n        }\n        this.segmentId.forEach((i) => {\n          this.collapse(i);\n        });\n      },\n      collapse(d) {\n        if (d.children) {\n          let dur = d.endTime - d.startTime;\n          d.children.forEach((i) => {\n            dur -= (i.endTime - i.startTime);\n          });\n          d.dur = dur < 0 ? 0 : dur;\n          d.children.forEach((i) => this.collapse(i));\n        }\n      },\n      showCurrentSpanDetail(title, text) {\n        const textLineNumber = text.split('\\n').length;\n        let textHeight = textLineNumber * 20.2 + 10;\n        const tmpHeight = window.innerHeight * 0.9;\n        textHeight = textHeight >= tmpHeight ? tmpHeight : textHeight;\n        this.$modal.show('dialog', {\n          title,\n          text: `<div style=\"height:${textHeight}px\">${text}</div>`,\n          buttons: [\n            {\n              title: 'Copy',\n              handler: () => {\n                this.copy(text);\n              },\n            },\n            {\n              title: 'Close',\n            },\n          ],\n        });\n      },\n      downloadTrace() {\n        const serializer = new XMLSerializer();\n        const svgNode = d3.select('.trace-list-dowanload').node();\n        const source = `<?xml version=\"1.0\" standalone=\"no\"?>\\r\\n${serializer.serializeToString(svgNode)}`;\n        const canvas = document.createElement('canvas');\n        const context = canvas.getContext('2d');\n        canvas.width = d3.select('.trace-list-dowanload')._groups[0][0].clientWidth;\n        canvas.height = d3.select('.trace-list-dowanload')._groups[0][0].clientHeight;\n        context.fillStyle = '#fff';\n        context.fillRect(0, 0, canvas.width, canvas.height);\n        const image = new Image();\n        image.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(source)}`;\n        image.onload = () => {\n          context.drawImage(image, 0, 0);\n          const tagA = document.createElement('a');\n          tagA.download = 'trace-list.png';\n          tagA.href = canvas.toDataURL('image/png');\n          tagA.click();\n        };\n      },\n    },\n  };\n</script>\n<style lang=\"scss\">\n  .time-charts {\n    overflow: auto;\n    padding: 10px 30px;\n    position: relative;\n    min-height: 150px;\n  }\n  .trace-node .group {\n    cursor: pointer;\n    fill-opacity: 0;\n  }\n  .trace-node-container {\n    fill: rgba(0, 0, 0, 0);\n    stroke-width: 5px;\n    cursor: pointer;\n    &:hover {\n      fill: rgba(0, 0, 0, 0.05);\n    }\n  }\n  .trace-node .node-text {\n    font: 12.5px sans-serif;\n    pointer-events: none;\n  }\n  .domain {\n    display: none;\n  }\n  .time-charts-item {\n    display: inline-block;\n    padding: 2px 8px;\n    border: 1px solid;\n    font-size: 11px;\n    border-radius: 4px;\n  }\n  .trace-list {\n    fill: rgba(0, 0, 0, 0);\n  }\n  .trace-list .trace-node rect {\n    &:hover {\n      fill: rgba(0, 0, 0, 0.05);\n    }\n  }\n  .dialog-c-text {\n    white-space: pre;\n    overflow: auto;\n    font-family: monospace;\n  }\n</style>\n"]}]}